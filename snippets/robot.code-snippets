{
  // Tennis Ball Robot Project Code Snippets
  
  // OpenSCAD Snippets
  "Honeycomb Pattern": {
    "prefix": "honeycomb",
    "scope": "scad,openscad",
    "body": [
      "module honeycomb_pattern(width, length, height) {",
      "    cell_size = ${1:10};",
      "    wall_thickness = ${2:1.2};",
      "    ",
      "    for(x = [0 : cell_size*1.5 : width]) {",
      "        for(y = [0 : cell_size*sqrt(3) : length]) {",
      "            translate([x + (y/cell_size/sqrt(3))%2 * cell_size*0.75, y, 0])",
      "                difference() {",
      "                    cylinder(h=height, r=cell_size/2, \\$fn=6);",
      "                    translate([0, 0, -1])",
      "                        cylinder(h=height+2, r=cell_size/2-wall_thickness, \\$fn=6);",
      "                }",
      "        }",
      "    }",
      "}"
    ],
    "description": "Create a honeycomb infill pattern"
  },
  
  "Robot Frame Component": {
    "prefix": "frame",
    "scope": "scad,openscad",
    "body": [
      "module ${1:component_name}() {",
      "    // Component parameters",
      "    thickness = ${2:3};",
      "    infill = ${3:0.2}; // 20% infill",
      "    ",
      "    difference() {",
      "        // Main shape",
      "        cube([${4:100}, ${5:50}, ${6:20}]);",
      "        ",
      "        // Honeycomb cutouts",
      "        translate([thickness, thickness, -1])",
      "            honeycomb_pattern(${4:100}-thickness*2, ${5:50}-thickness*2, ${6:20}+2);",
      "    }",
      "}"
    ],
    "description": "Create a robot frame component with honeycomb infill"
  },
  
  // Python Snippets
  "ROS2 Node": {
    "prefix": "ros2node",
    "scope": "python",
    "body": [
      "import rclpy",
      "from rclpy.node import Node",
      "",
      "class ${1:NodeName}(Node):",
      "    def __init__(self):",
      "        super().__init__('${2:node_name}')",
      "        self.get_logger().info('${1:NodeName} initialized')",
      "        ${0}",
      "",
      "def main(args=None):",
      "    rclpy.init(args=args)",
      "    node = ${1:NodeName}()",
      "    rclpy.spin(node)",
      "    node.destroy_node()",
      "    rclpy.shutdown()",
      "",
      "if __name__ == '__main__':",
      "    main()"
    ],
    "description": "Create a ROS2 node template"
  },
  
  "Ball Detection": {
    "prefix": "balldetect",
    "scope": "python",
    "body": [
      "import cv2",
      "import numpy as np",
      "",
      "def detect_tennis_balls(image):",
      "    \"\"\"Detect tennis balls in image using color and shape.\"\"\"",
      "    # Convert to HSV for better color detection",
      "    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)",
      "    ",
      "    # Tennis ball color range (adjust based on lighting)",
      "    lower_yellow = np.array([${1:25}, ${2:50}, ${3:50}])",
      "    upper_yellow = np.array([${4:35}, ${5:255}, ${6:255}])",
      "    ",
      "    # Create mask",
      "    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)",
      "    ",
      "    # Find contours",
      "    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)",
      "    ",
      "    balls = []",
      "    for contour in contours:",
      "        area = cv2.contourArea(contour)",
      "        if area > ${7:500}:  # Minimum area threshold",
      "            # Check circularity",
      "            perimeter = cv2.arcLength(contour, True)",
      "            circularity = 4 * np.pi * area / (perimeter * perimeter)",
      "            if circularity > ${8:0.7}:",
      "                # Get bounding circle",
      "                (x, y), radius = cv2.minEnclosingCircle(contour)",
      "                balls.append({'x': int(x), 'y': int(y), 'radius': int(radius)})",
      "    ",
      "    return balls"
    ],
    "description": "Tennis ball detection function"
  },
  
  "Motor Control": {
    "prefix": "motorcontrol",
    "scope": "python",
    "body": [
      "import RPi.GPIO as GPIO",
      "import time",
      "",
      "class MotorController:",
      "    def __init__(self, enable_pin=${1:18}, in1_pin=${2:23}, in2_pin=${3:24}):",
      "        self.enable_pin = enable_pin",
      "        self.in1_pin = in1_pin",
      "        self.in2_pin = in2_pin",
      "        ",
      "        # Setup GPIO",
      "        GPIO.setmode(GPIO.BCM)",
      "        GPIO.setup(self.enable_pin, GPIO.OUT)",
      "        GPIO.setup(self.in1_pin, GPIO.OUT)",
      "        GPIO.setup(self.in2_pin, GPIO.OUT)",
      "        ",
      "        # Setup PWM",
      "        self.pwm = GPIO.PWM(self.enable_pin, ${4:1000})  # 1kHz frequency",
      "        self.pwm.start(0)",
      "    ",
      "    def forward(self, speed=${5:50}):",
      "        \"\"\"Move motor forward at given speed (0-100).\"\"\"",
      "        GPIO.output(self.in1_pin, GPIO.HIGH)",
      "        GPIO.output(self.in2_pin, GPIO.LOW)",
      "        self.pwm.ChangeDutyCycle(speed)",
      "    ",
      "    def reverse(self, speed=${5:50}):",
      "        \"\"\"Move motor in reverse at given speed (0-100).\"\"\"",
      "        GPIO.output(self.in1_pin, GPIO.LOW)",
      "        GPIO.output(self.in2_pin, GPIO.HIGH)",
      "        self.pwm.ChangeDutyCycle(speed)",
      "    ",
      "    def stop(self):",
      "        \"\"\"Stop motor.\"\"\"",
      "        self.pwm.ChangeDutyCycle(0)",
      "    ",
      "    def cleanup(self):",
      "        \"\"\"Clean up GPIO resources.\"\"\"",
      "        self.pwm.stop()",
      "        GPIO.cleanup()"
    ],
    "description": "Motor control class for Raspberry Pi"
  },
  
  "State Machine": {
    "prefix": "statemachine",
    "scope": "python",
    "body": [
      "from enum import Enum, auto",
      "",
      "class RobotState(Enum):",
      "    IDLE = auto()",
      "    COLLECTING = auto()",
      "    NAVIGATING = auto()",
      "    DEPOSITING = auto()",
      "    CHARGING = auto()",
      "    ERROR = auto()",
      "",
      "class RobotStateMachine:",
      "    def __init__(self):",
      "        self.state = RobotState.IDLE",
      "        self.mode = '${1:practice}'  # 'practice' or 'clinic'",
      "        ",
      "    def transition(self, new_state):",
      "        \"\"\"Transition to new state with validation.\"\"\"",
      "        valid_transitions = {",
      "            RobotState.IDLE: [RobotState.COLLECTING, RobotState.CHARGING],",
      "            RobotState.COLLECTING: [RobotState.NAVIGATING, RobotState.ERROR],",
      "            RobotState.NAVIGATING: [RobotState.DEPOSITING, RobotState.COLLECTING, RobotState.ERROR],",
      "            RobotState.DEPOSITING: [RobotState.IDLE, RobotState.COLLECTING],",
      "            RobotState.CHARGING: [RobotState.IDLE],",
      "            RobotState.ERROR: [RobotState.IDLE]",
      "        }",
      "        ",
      "        if new_state in valid_transitions.get(self.state, []):",
      "            print(f'Transitioning from {self.state} to {new_state}')",
      "            self.state = new_state",
      "            return True",
      "        else:",
      "            print(f'Invalid transition from {self.state} to {new_state}')",
      "            return False",
      "    ",
      "    def update(self):",
      "        \"\"\"Update state machine based on current state.\"\"\"",
      "        if self.state == RobotState.IDLE:",
      "            ${0:# Check for balls to collect}",
      "            pass",
      "        elif self.state == RobotState.COLLECTING:",
      "            # Collect ball logic",
      "            pass",
      "        # Add more state handlers..."
    ],
    "description": "Robot state machine template"
  },
  
  // G-Code Snippets
  "Print Header": {
    "prefix": "gcodeheader",
    "scope": "gcode",
    "body": [
      "; Tennis Ball Robot Component",
      "; File: ${1:component_name}",
      "; Material: ${2:PETG}",
      "; Layer Height: ${3:0.2}mm",
      "; Infill: ${4:20}%",
      "; Print Time: ${5:4h 30m}",
      ";",
      "G28 ; Home all axes",
      "G29 ; Auto bed leveling",
      "M190 S${6:70} ; Wait for bed temp",
      "M109 S${7:240} ; Wait for hotend temp",
      "G92 E0 ; Reset extruder",
      "G1 Z0.3 F3000 ; Move to start height",
      "${0}"
    ],
    "description": "G-code print header"
  },
  
  // Markdown Documentation Snippets
  "Component Documentation": {
    "prefix": "componentdoc",
    "scope": "markdown",
    "body": [
      "## ${1:Component Name}",
      "",
      "### Overview",
      "${2:Brief description of the component}",
      "",
      "### Specifications",
      "- **Material**: ${3:PETG}",
      "- **Infill**: ${4:20%}",
      "- **Layer Height**: ${5:0.2mm}",
      "- **Print Time**: ${6:4 hours}",
      "- **Weight**: ${7:150g}",
      "",
      "### Assembly Notes",
      "${8:Assembly instructions}",
      "",
      "### Testing",
      "- [ ] Print quality check",
      "- [ ] Dimension verification",
      "- [ ] Strength test",
      "- [ ] Integration test",
      "",
      "### Files",
      "- CAD: `models/${1}.scad`",
      "- STL: `models/${1}.stl`",
      "- G-Code: `models/${1}.gcode`"
    ],
    "description": "Component documentation template"
  }
}